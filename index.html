<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPGPU Particles — Three.js</title>
  <style>
    html, body {
      background: #16152b;
      margin: 0; padding: 0;
      overflow: hidden;
      width: 100vw; height: 100vh;
    }
    #container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Three.js r87 e libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.87.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.87.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r87/examples/js/GPUComputationRenderer.js"></script>

  <script>
    // === CONFIG ===
    var PARTICLE_SIZE = 2.0;
    var WIDTH = 128;
    var PARTICLES = WIDTH * WIDTH;
    var container, camera, scene, renderer, controls;
    var gpuCompute, velocityVariable, positionVariable;
    var positionUniforms, velocityUniforms, particleUniforms;
    var effectController = { separation: 40.0, alignment: 30.0, cohesion: 30.0, freedom: 0.75, predator: false };

    init();
    animate();

    function init() {
      container = document.getElementById('container');
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 5, 10000);
      camera.position.z = 350;
      scene = new THREE.Scene();

      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0x16152b, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);

      if (renderer.capabilities.isWebGL2 === false && !renderer.extensions.get('OES_texture_float')) {
        alert('O seu navegador não suporta WebGL Float Textures! Tente outro navegador.');
        return;
      }

      var dtPosition = gpuCompute.createTexture();
      var dtVelocity = gpuCompute.createTexture();
      fillPositionTexture(dtPosition);
      fillVelocityTexture(dtVelocity);

      velocityVariable = gpuCompute.addVariable("textureVelocity", velocityShader(), dtVelocity);
      positionVariable = gpuCompute.addVariable("texturePosition", positionShader(), dtPosition);

      gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);
      gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);

      velocityUniforms = velocityVariable.material.uniforms;
      positionUniforms = positionVariable.material.uniforms;

      velocityUniforms['time'] = { value: 0.0 };
      velocityUniforms['delta'] = { value: 0.0 };
      velocityUniforms['separationDistance'] = { value: 1.0 };
      velocityUniforms['alignmentDistance'] = { value: 1.0 };
      velocityUniforms['cohesionDistance'] = { value: 1.0 };
      velocityUniforms['freedomFactor'] = { value: 1.0 };

      positionUniforms['time'] = { value: 0.0 };
      positionUniforms['delta'] = { value: 0.0 };

      var error = gpuCompute.init();
      if (error !== null) {
        alert(error);
      }

      // Particle Geometry
      var geometry = new THREE.BufferGeometry();
      var positions = new Float32Array(PARTICLES * 3);
      var references = new Float32Array(PARTICLES * 2);

      var p = 0;
      for (var i = 0; i < WIDTH; i++) {
        for (var j = 0; j < WIDTH; j++) {
          positions[3 * p    ] = 0;
          positions[3 * p + 1] = 0;
          positions[3 * p + 2] = 0;
          references[2 * p    ] = i / (WIDTH - 1);
          references[2 * p + 1] = j / (WIDTH - 1);
          p++;
        }
      }
      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.addAttribute('reference', new THREE.BufferAttribute(references, 2));

      // Particle Material
      var material = new THREE.ShaderMaterial({
        uniforms: {
          "map": { value: new THREE.TextureLoader().load('https://ykob.github.io/sketch-threejs/img/dot.png') },
          "texturePosition": { value: null },
          "textureVelocity": { value: null },
          "cameraConstant": { value: getCameraConstant(camera) }
        },
        vertexShader: particleVertexShader(),
        fragmentShader: particleFragmentShader(),
        transparent: true
      });

      var particles = new THREE.Points(geometry, material);
      particles.matrixAutoUpdate = false;
      particles.updateMatrix();
      scene.add(particles);

      particleUniforms = material.uniforms;

      window.addEventListener('resize', onWindowResize, false);
    }

    function fillPositionTexture(texture) {
      var data = texture.image.data;
      for (var k = 0, kl = data.length; k < kl; k += 4) {
        var x = Math.random() * 400 - 200;
        var y = Math.random() * 400 - 200;
        var z = Math.random() * 400 - 200;
        data[k + 0] = x;
        data[k + 1] = y;
        data[k + 2] = z;
        data[k + 3] = 1;
      }
    }

    function fillVelocityTexture(texture) {
      var data = texture.image.data;
      for (var k = 0, kl = data.length; k < kl; k += 4) {
        var x = Math.random() - 0.5;
        var y = Math.random() - 0.5;
        var z = Math.random() - 0.5;
        data[k + 0] = x * 10;
        data[k + 1] = y * 10;
        data[k + 2] = z * 10;
        data[k + 3] = 1;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      particleUniforms.cameraConstant.value = getCameraConstant(camera);
    }

    function getCameraConstant(camera) {
      return window.innerHeight / (Math.tan(THREE.Math.degToRad(camera.fov) / 2) / camera.zoom);
    }

    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      var now = performance.now();
      var delta = 0.016;

      velocityUniforms['time'].value = now / 1000;
      velocityUniforms['delta'].value = delta;
      velocityUniforms['separationDistance'].value = effectController.separation;
      velocityUniforms['alignmentDistance'].value = effectController.alignment;
      velocityUniforms['cohesionDistance'].value = effectController.cohesion;
      velocityUniforms['freedomFactor'].value = effectController.freedom;

      positionUniforms['time'].value = now / 1000;
      positionUniforms['delta'].value = delta;

      gpuCompute.compute();

      particleUniforms["texturePosition"].value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
      particleUniforms["textureVelocity"].value = gpuCompute.getCurrentRenderTarget(velocityVariable).texture;

      renderer.render(scene, camera);
    }

    // ========== SHADERS ==========

    function velocityShader() {
      // Shader de velocidade (fragment) — sem varying
      return `
        uniform float time;
        uniform float delta;
        uniform float separationDistance;
        uniform float alignmentDistance;
        uniform float cohesionDistance;
        uniform float freedomFactor;
        uniform sampler2D texturePosition;
        uniform sampler2D textureVelocity;
        void main() {
          vec2 uv = gl_FragCoord.xy / resolution.xy;
          vec3 pos = texture2D(texturePosition, uv).xyz;
          vec3 vel = texture2D(textureVelocity, uv).xyz;
          vel += vec3(
            (fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.5,
            (fract(sin(dot(pos.yz, vec2(93.9898, 67.345))) * 23758.5453) - 0.5) * 0.5,
            (fract(sin(dot(pos.zx, vec2(56.7213, 12.9898))) * 53758.5453) - 0.5) * 0.5
          ) * delta * freedomFactor;
          gl_FragColor = vec4(vel, 1.0);
        }
      `;
    }

    function positionShader() {
      // Shader de posição (fragment) — sem varying
      return `
        uniform float time;
        uniform float delta;
        uniform sampler2D texturePosition;
        uniform sampler2D textureVelocity;
        void main() {
          vec2 uv = gl_FragCoord.xy / resolution.xy;
          vec3 pos = texture2D(texturePosition, uv).xyz;
          vec3 vel = texture2D(textureVelocity, uv).xyz;
          gl_FragColor = vec4(pos + vel * delta, 1.0);
        }
      `;
    }

    function particleVertexShader() {
      // Vertex shader dos pontos
      return `
        uniform sampler2D texturePosition;
        uniform sampler2D textureVelocity;
        uniform float cameraConstant;
        attribute vec2 reference;
        varying vec4 vColor;
        void main() {
          vec4 posTemp = texture2D(texturePosition, reference);
          vec3 pos = posTemp.xyz;
          vec3 vel = texture2D(textureVelocity, reference).xyz;
          float speed = length(vel);
          vColor = vec4(mix(vec3(1.0,0.0,1.0), vec3(0.6,1.0,0.8), speed/10.0), 1.0);
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = cameraConstant / (-mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `;
    }

    function particleFragmentShader() {
      // Fragment shader dos pontos
      return `
        uniform sampler2D map;
        varying vec4 vColor;
        void main() {
          gl_FragColor = vColor * texture2D(map, gl_PointCoord);
          if (gl_FragColor.a < 0.5) discard;
        }
      `;
    }
  </script>
</body>
</html>
