<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPGPU Particles — Three.js (Ykob)</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      width: 100vw; height: 100vh; background: #17142a;
    }
    body { position: relative; }
    #container {
      position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Three.js r87 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.87.1/build/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.87.1/examples/js/controls/OrbitControls.js"></script>
  <!-- GPUComputationRenderer -->
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r87/examples/js/GPUComputationRenderer.js"></script>

  <!-- === Shaders do CodePen (igual ao Ykob) === -->
  <script id="velocityFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    uniform float delta;
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec4 pos = texture2D(texturePosition, uv);
      vec4 vel = texture2D(textureVelocity, uv);
      float dist = length(pos.xyz);
      vel.xyz += normalize(pos.xyz) * (-0.01 + 0.02 * smoothstep(1.0, 2.0, dist));
      gl_FragColor = vel;
    }
  </script>
  <script id="positionFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D texturePosition;
    uniform sampler2D textureVelocity;
    uniform float delta;
    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec4 pos = texture2D(texturePosition, uv);
      vec4 vel = texture2D(textureVelocity, uv);
      pos.xyz += vel.xyz * delta * 1.5;
      gl_FragColor = pos;
    }
  </script>
  <script id="particleVertexShader" type="x-shader/x-vertex">
    uniform sampler2D texturePosition;
    uniform float time;
    varying vec4 vColor;
    void main() {
      vec4 posTemp = texture2D(texturePosition, uv);
      vec3 pos = posTemp.xyz;
      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = 2.0 * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
      float hue = mod(time * 0.1 + length(pos) * 0.15, 1.0);
      vColor = vec4(hue, 0.7, 1.0, 1.0);
    }
  </script>
  <script id="particleFragmentShader" type="x-shader/x-fragment">
    varying vec4 vColor;
    vec3 hsv2rgb(vec3 c) {
      vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }
    void main() {
      float r = length(gl_PointCoord - 0.5);
      if (r > 0.5) discard;
      gl_FragColor = vec4(hsv2rgb(vColor.xyz), vColor.w * (1.0 - r * 1.3));
    }
  </script>

  <!-- === Código JS principal (adaptado do CodePen) === -->
  <script>
    // Adaptação do https://codepen.io/ykob/pen/WpNxaR
    var container = document.getElementById('container');
    var width = window.innerWidth;
    var height = window.innerHeight;
    var PARTICLE_RES = 128; // 128 x 128 = 16.384 partículas (ajuste aqui!)
    var PARTICLE_NUM = PARTICLE_RES * PARTICLE_RES;

    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0x17142a, 1); // igual fundo
    renderer.setSize(width, height);
    container.appendChild(renderer.domElement);

    var camera = new THREE.PerspectiveCamera(75, width / height, 1, 1000);
    camera.position.z = 120;

    var scene = new THREE.Scene();

    // GPUComputationRenderer
    var gpuCompute = new GPUComputationRenderer(PARTICLE_RES, PARTICLE_RES, renderer);

    // Criação das texturas iniciais
    function fillPositionTexture(texture) {
      var arr = texture.image.data;
      for (var k = 0, kl = arr.length; k < kl; k += 4) {
        var phi = Math.random() * 2 * Math.PI;
        var costheta = Math.random() * 2 - 1;
        var theta = Math.acos(costheta);
        var r = 60 + Math.random() * 10;
        arr[k + 0] = r * Math.sin(theta) * Math.cos(phi);
        arr[k + 1] = r * Math.sin(theta) * Math.sin(phi);
        arr[k + 2] = r * Math.cos(theta);
        arr[k + 3] = 1;
      }
    }
    function fillVelocityTexture(texture) {
      var arr = texture.image.data;
      for (var k = 0, kl = arr.length; k < kl; k += 4) {
        arr[k + 0] = (Math.random() - 0.5) * 0.2;
        arr[k + 1] = (Math.random() - 0.5) * 0.2;
        arr[k + 2] = (Math.random() - 0.5) * 0.2;
        arr[k + 3] = 1;
      }
    }

    var dtPosition = gpuCompute.createTexture();
    var dtVelocity = gpuCompute.createTexture();
    fillPositionTexture(dtPosition);
    fillVelocityTexture(dtVelocity);

    var velocityVariable = gpuCompute.addVariable("textureVelocity",
      document.getElementById("velocityFragmentShader").textContent, dtVelocity);
    var positionVariable = gpuCompute.addVariable("texturePosition",
      document.getElementById("positionFragmentShader").textContent, dtPosition);

    gpuCompute.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);
    gpuCompute.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);
    velocityVariable.material.uniforms.delta = { value: 0 };
    positionVariable.material.uniforms.delta = { value: 0 };

    var error = gpuCompute.init();
    if (error !== null) {
      alert(error);
    }

    // Geometria dos pontos
    var geometry = new THREE.BufferGeometry();
    var positions = new Float32Array(PARTICLE_NUM * 3);
    var uvs = new Float32Array(PARTICLE_NUM * 2);
    var p = 0, u = 0;
    for (var i = 0; i < PARTICLE_RES; i++) {
      for (var j = 0; j < PARTICLE_RES; j++) {
        uvs[u++] = i / (PARTICLE_RES - 1);
        uvs[u++] = j / (PARTICLE_RES - 1);
        positions[p++] = 0;
        positions[p++] = 0;
        positions[p++] = 0;
      }
    }
    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

    // Material com shaders
    var material = new THREE.ShaderMaterial({
      uniforms: {
        texturePosition: { value: null },
        time: { value: 0 }
      },
      vertexShader: document.getElementById('particleVertexShader').textContent,
      fragmentShader: document.getElementById('particleFragmentShader').textContent,
      transparent: true
    });

    var points = new THREE.Points(geometry, material);
    scene.add(points);

    // Animação
    var clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      var delta = clock.getDelta();
      velocityVariable.material.uniforms.delta.value = delta;
      positionVariable.material.uniforms.delta.value = delta;

      gpuCompute.compute();

      material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
      material.uniforms.time.value += delta;

      renderer.render(scene, camera);
    }
    animate();

    // Responsivo
    window.addEventListener('resize', function () {
      width = window.innerWidth;
      height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
